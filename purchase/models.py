""" Models for managing purchases """

from datetime import datetime, date
from django.utils.translation import gettext_lazy as _
from django.db import models
from django.db.models import F, FloatField, Sum

from accounts.models import User
from product.models import ProductInstance, DiopterPower, Cylinder


def docs_directory_path(filename):
    """  file will be uploaded to MEDIA_ROOT/invoices/Year/Month/<filename> """
    return 'invoices/{0}/{1}/{2}'.format(datetime.now().year, datetime.now().month, filename)


class Purchase(models.Model):
    """ Abstract Model contains Purchases """
    products = models.ManyToManyField(ProductInstance, through='PurchaseLine', related_name='purchases',
                                      verbose_name=_('Goods'), blank=True)
    invoice_number = models.CharField(_('Invoice number'), max_length=45)
    comment = models.CharField(_('Comment'), max_length=255, blank=True)
    # Creator and Date information
    created_by = models.ForeignKey(User, verbose_name=_('Created by'), related_name='creator_purchases',
                                   blank=True, null=True, on_delete=models.CASCADE)
    date_created = models.DateTimeField(_("Date created"), auto_now_add=True)
    date_updated = models.DateTimeField(_("Date updated"), auto_now=True, db_index=True)

    class Meta:
        verbose_name = _('Purchase')
        verbose_name_plural = _('Purchases')
        ordering = ['-date_created', '-invoice_number']

    def __str__(self):
        return self.invoice_number

    @classmethod
    def invoice_number_generate(cls):
        """ return autogenerated invoice number"""
        today_str = date.today().strftime('%Y%m%d')
        today_orders_count = cls.objects.filter(date_created__contains=date.today()) \
                                        .exclude(invoice_number='InProcess') \
                                        .count()
        return today_str + '-' + str(today_orders_count + 1)
    invoice_number_generate.short_description = _('Generate invoice number')


class Order(models.Model):
    """ Model contains Sales, Carts """
    InCart = 'IC'
    NewOrder = 'NO'
    Cancelled = 'CN'
    Confirmed = 'CF'
    PreOrder = 'PO'
    Returned = 'RT'
    STATUS_CHOICES = (
        (InCart, _('Products in cart')),
        (NewOrder, _('New order')),
        (Cancelled, _('Order canceled')),
        (Confirmed, _('Order confirmed')),
        (PreOrder, _('Pre-order')),
        (Returned, _('Order returned')),
    )
    products = models.ManyToManyField(ProductInstance, through='OrderLine', related_name='orders',
                                      verbose_name=_('Goods'), blank=True)
    customer = models.ForeignKey(User, verbose_name=_('Customer'), on_delete=models.CASCADE)
    invoice_number = models.CharField(_('Invoice number'), max_length=45)
    comment = models.CharField(_('Comment'), max_length=255, blank=True)
    status = models.CharField(_('Order status'), max_length=2, choices=STATUS_CHOICES, default=InCart)
    old_status = models.CharField(max_length=2, choices=STATUS_CHOICES, default=NewOrder)
    value = models.DecimalField(_('Price'), max_digits=8, decimal_places=2, default=0)
    lenses_sum = models.PositiveSmallIntegerField(_('Sum'), blank=True, null=True)
    # Creator and Date information
    created_by = models.ForeignKey(User, verbose_name=_('Created by'), related_name='creator_orders',
                                   blank=True, null=True, on_delete=models.CASCADE)
    date_created = models.DateTimeField(_("Date created"), auto_now_add=True)
    date_updated = models.DateTimeField(_("Date updated"), auto_now=True, db_index=True)

    class Meta:
        verbose_name = _('Order')
        verbose_name_plural = _('Orders')
        ordering = ['-date_created', 'invoice_number']

    def __str__(self):
        return self.invoice_number

    def value_total(self):
        """ return total order value"""
        return self.orderline_set.aggregate(total_value=Sum(F('quantity')*F('unit_price'),
                                                            output_field=FloatField())) \
                                            ['total_value'] or 0
    value_total.short_description = _('Total order value')

    def available_total(self):
        """ return total available value"""
        return self.orderline_set.filter(order_type=OrderLine.AvailableOrder) \
                                 .aggregate(total_value=Sum(F('quantity')*F('unit_price'),
                                                            output_field=FloatField())) \
                                            ['total_value'] or 0
    available_total.short_description = _('Total available value')

    def preorder_total(self):
        """ return total preorder value"""
        return self.orderline_set.filter(order_type=OrderLine.PreOrder) \
                                 .aggregate(total_value=Sum(F('quantity')*F('unit_price'),
                                                            output_field=FloatField())) \
                                            ['total_value'] or 0
    preorder_total.short_description = _('Total preorder value')

    def lenses_count(self):
        """ return total count of lences in order """
        return self.orderline_set.aggregate(total_value=Sum('quantity')) \
                                           ['total_value'] or 0
    lenses_count.short_description = _('Total lenses count in order')

    @classmethod
    def invoice_number_generate(cls):
        """ return autogenerated invoice number"""
        today_str = date.today().strftime('%Y%m%d')
        today_orders_count = cls.objects.filter(date_created__contains=date.today()) \
                                        .exclude(status=Order.InCart) \
                                        .count() + 1
        return f"{today_str}-{today_orders_count}"
    invoice_number_generate.short_description = _('Generate invoice number')


class PurchaseLine(models.Model):
    """ Model contains InvoiceLines for Purchases model """
    purchase = models.ForeignKey(Purchase, verbose_name=_('Purchase'), on_delete=models.CASCADE)
    product = models.ForeignKey(ProductInstance, verbose_name=_('Goods'), on_delete=models.PROTECT)
    diopter = models.ForeignKey(DiopterPower, on_delete=models.PROTECT)
    cylinder = models.ForeignKey(Cylinder, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField(_('Quantity'), default=0)
    last_quantity = models.PositiveSmallIntegerField(default=0)

    class Meta:
        unique_together = ['purchase', 'product']

    def save(self, *args, **kwargs):
        self.last_quantity = self.quantity
        super().save(*args, **kwargs) # Call the real save() method


class OrderLine(models.Model):
    """ Model contains InvoiceLines for Purchases model """
    AvailableOrder = 'AO'
    PreOrder = 'PO'
    ORDER_CHOICES = (
        (AvailableOrder, _('Order')),
        (PreOrder, _('Pre-order')),
    )
    order = models.ForeignKey(Order, verbose_name=_('Order'), on_delete=models.CASCADE)
    product = models.ForeignKey(ProductInstance, verbose_name=_('Goods'), on_delete=models.PROTECT)
    diopter = models.ForeignKey(DiopterPower, on_delete=models.PROTECT)
    cylinder = models.ForeignKey(Cylinder, on_delete=models.PROTECT)
    quantity = models.PositiveSmallIntegerField(_('Quantity'), default=0)
    last_quantity = models.PositiveSmallIntegerField(default=0)
    unit_price = models.DecimalField(_('Unit price'), max_digits=8, decimal_places=2, default=0)
    order_type = models.CharField(_('Order type'), max_length=2, choices=ORDER_CHOICES, default=AvailableOrder)

    def save(self, *args, **kwargs):
        if self.order_type == self.AvailableOrder:
            self.last_quantity = self.quantity
        super().save(*args, **kwargs) # Call the real save() method

    def value_total(self):
        """ return calculated invoice_line value"""
        return self.unit_price * self.quantity
    value_total.short_description = _('Calculated invoice_line value')
